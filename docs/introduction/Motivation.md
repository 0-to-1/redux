# 動機

シングルページアプリケーションとしてのJavaScriptの必要性が増してきています。そのため私たちのコードはかつてないほど多くの状態を管理しなければなりません。状態には、サーバからの応答やキャッシュデータが含まれます。ローカルでつくられて、まだサーバと整合が取れていないデータも状態です。
UIの状態は、複雑性を増しています。動的ルート、タブ選択、スピナー、ページネーション（ページ繰り）の制御なども管理しないといけません。

この変わり続ける状態を管理するのは、大変です。もしモデルが別のモデルを更新するとしたら、ビューがモデルを更新することもあり得るし、それが別のモデルを更新するかもしれないし、それが今度は、別のビューの更新を引き起こすかもしれません。どこかの時点で、もはやアプリで何が起こっているのか分からなくなります。いつ、なぜ、どのように状態が変わるのか、 制御できなくなってしまうのです。システムが不明瞭で予見不能だと、バグを再現したり新しい機能を追加するのが難しくなります。

もしこれでも充分悪くないと思うなら、フロントエンドのプロダクト開発で新たな要件が一般的になりつつあるのをよく考えてください。開発者として、楽観更新（訳注：サーバとの非同期処理が成功するという前提で、サーバの応答を待たずにフロントを更新すること）や、サーバサイドレンダリング、ルート遷移前のデータ取得などへの対処を期待されています。かつてない複雑性を管理しようとしていることに気付かされ、この質問をせずにはいられません: [諦めるときなのか？ (is it time to give up?)](http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html) その答えは、Noです。

この複雑性に対処するのが難しい理由は、**２つの概念を混ぜ合わせているから** です。その２つとは、人間にとって理解するのが難しい **変更と非同期性** です。 私はこれを、[メントスとコーラ (Mentos and Coke)](https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption)と呼んでいます。別々だと素晴らしい。でも一緒にすると、めちゃくちゃになる。 [React](http://facebook.github.io/react)のようなライブラリは、この問題をビュー層で解決しようと試みています。解決方法は、非同期性と直接的なDOM操作の両方を取り除くことです。しかし、データの状態管理は開発者任せです。ここに、Reduxの入る余地があります。

[Flux](http://facebook.github.io/flux)、 [CQRS](http://martinfowler.com/bliki/CQRS.html)、 そして[Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html)というステップに従い、 **Reduxは状態変化を予測可能にしようと試みています。** その方法は、どのように、そしていつ更新が起きるかについて一定の制限を課すことです。これらの制限は、Reduxの[３つの原則](ThreePrinciples.md)に反映されています。
